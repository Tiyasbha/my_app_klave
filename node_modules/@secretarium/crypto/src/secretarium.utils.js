"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashBase64 = exports.hash = exports.getRandomString = exports.encode = exports.decode = exports.concatBytesArrays = exports.concatBytes = exports.getRandomBytes = exports.toHex = exports.fromBase64 = exports.toBase64 = exports.sequenceEqual = exports.incrementBy = exports.xor = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const js_base64_1 = require("js-base64");
const crypto_1 = require("@secretarium/crypto");
function xor(a, b) {
    if (a.length !== b.length)
        throw new Error();
    return a.map((x, i) => x ^ b[i]);
}
exports.xor = xor;
function incrementBy(src, offset) {
    const inc = Uint8Array.from(src), szDiff = src.length - offset.length;
    for (let j = offset.length - 1; j >= 0; j--) {
        for (let i = j + szDiff, o = offset[j]; i >= 0; i--) {
            if (inc[i] + o > 255) {
                inc[i] = inc[i] + o - 256;
                o = 1;
            }
            else {
                inc[i] = inc[i] + o;
                break;
            }
        }
    }
    return inc;
}
exports.incrementBy = incrementBy;
function sequenceEqual(a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i !== a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
exports.sequenceEqual = sequenceEqual;
function toBase64(src, urlSafeMode = false) {
    const x = (0, js_base64_1.btoa)(String.fromCharCode.apply(null, Array.from(src)));
    return urlSafeMode ? x.replace(/\+/g, '-').replace(/\//g, '_') : x;
}
exports.toBase64 = toBase64;
function fromBase64(enc) {
    const x = enc.replace(/-/g, '+').replace(/_/g, '/');
    const str = (0, js_base64_1.atob)(x);
    const len = str.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
exports.fromBase64 = fromBase64;
const byteToHex = (new Array(256)).map(n => n.toString(16).padStart(2, '0'));
function toHex(src, delimiter = '') {
    return src.map(n => byteToHex[n]).join(delimiter);
}
exports.toHex = toHex;
function getRandomBytes(size = 32) {
    const a = new Uint8Array(size);
    crypto_1.default.getRandomValues(a);
    return a;
}
exports.getRandomBytes = getRandomBytes;
function concatBytes(a, b) {
    const c = new Uint8Array(a.length + b.length);
    c.set(a, 0);
    c.set(b, a.length);
    return c;
}
exports.concatBytes = concatBytes;
function concatBytesArrays(arrays) {
    let length = 0;
    for (let i = 0; i < arrays.length; i++) {
        length += arrays[i].length;
    }
    const c = new Uint8Array(length);
    for (let i = 0, j = 0; i < arrays.length; i++) {
        c.set(arrays[i], j);
        j += arrays[i].length;
    }
    return c;
}
exports.concatBytesArrays = concatBytesArrays;
function decode(octets, ignoreException = false) {
    let string = '';
    let i = 0;
    while (i < octets.length) {
        let octet = octets[i];
        let bytesNeeded = 0;
        let codePoint = 0;
        if (octet <= 0x7F) {
            bytesNeeded = 0;
            codePoint = octet & 0xFF;
        }
        else if (octet <= 0xDF) {
            bytesNeeded = 1;
            codePoint = octet & 0x1F;
        }
        else if (octet <= 0xEF) {
            bytesNeeded = 2;
            codePoint = octet & 0x0F;
        }
        else if (octet <= 0xF4) {
            bytesNeeded = 3;
            codePoint = octet & 0x07;
        }
        if (octets.length - i - bytesNeeded > 0) {
            let k = 0;
            while (k < bytesNeeded) {
                octet = octets[i + k + 1];
                codePoint = (codePoint << 6) | (octet & 0x3F);
                k += 1;
            }
        }
        else {
            codePoint = 0xFFFD;
            bytesNeeded = octets.length - i;
        }
        if (ignoreException)
            try {
                string += String.fromCodePoint(codePoint);
            }
            catch (e) { /* NOOP */ }
        else
            string += String.fromCodePoint(codePoint);
        i += bytesNeeded + 1;
    }
    return string;
}
exports.decode = decode;
function encode(s) {
    const length = s.length;
    const octets = new Array();
    let i = 0;
    while (i < length) {
        const codePoint = s.codePointAt(i);
        if (!codePoint)
            return new Uint8Array(octets);
        let c = 0;
        let bits = 0;
        if (codePoint <= 0x0000007F) {
            c = 0;
            bits = 0x00;
        }
        else if (codePoint <= 0x000007FF) {
            c = 6;
            bits = 0xC0;
        }
        else if (codePoint <= 0x0000FFFF) {
            c = 12;
            bits = 0xE0;
        }
        else if (codePoint <= 0x001FFFFF) {
            c = 18;
            bits = 0xF0;
        }
        octets.push(bits | (codePoint >> c));
        c -= 6;
        while (c >= 0) {
            octets.push(0x80 | ((codePoint >> c) & 0x3F));
            c -= 6;
        }
        i += codePoint >= 0x10000 ? 2 : 1;
    }
    return new Uint8Array(octets);
}
exports.encode = encode;
function getRandomString(size = 32) {
    const a = getRandomBytes(size);
    let final;
    while (!final) {
        final = decode(a, true);
    }
    return final;
}
exports.getRandomString = getRandomString;
function hash(data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return new Uint8Array(yield crypto_1.default.subtle.digest({ name: 'SHA-256' }, data));
    });
}
exports.hash = hash;
function hashBase64(s, urlSafeMode = false) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return toBase64(yield hash(encode(s)), urlSafeMode);
    });
}
exports.hashBase64 = hashBase64;
//# sourceMappingURL=secretarium.utils.js.map